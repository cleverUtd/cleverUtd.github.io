title: 线程池拒绝策略源码小析
date: 2017-11-10 15:17:15
categories: Java
tags: Core Java
---


- 提交一个新的task到线程池后，此时如果ThreadPool内的所有工作线程都在忙碌时（没有可用的线程去处理该task），并且任务队列也到达界限，这时候就需要用到拒绝策略。

- 在 java.util.concurrent包下有个RejectedExecutionHandler接口，该接口定义了rejectedExecution方法，用来实现具体的拒绝行为。

![image.png](http://upload-images.jianshu.io/upload_images/8923118-e39226683758c31e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 再往下看，Java预定义了四种拒绝策略：
![image.png](http://upload-images.jianshu.io/upload_images/8923118-08fa4589a940767c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 

下面就分析一下这四种拒绝策略有什么不一样：

### AbortPolicy
![image.png](http://upload-images.jianshu.io/upload_images/8923118-6d7b6ecd5323eb21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看到AbortPolicy其实就是直接抛了个exception，并丢弃该task。

### DiscardPolicy

![image.png](http://upload-images.jianshu.io/upload_images/8923118-0f93f7ce1cedd7e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

DiscardPolicy什么都没做，静静地丢弃该task


 ### DiscardOldestPolicy

![image.png](http://upload-images.jianshu.io/upload_images/8923118-80005ac373773c29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看到DiscardOldestPolicy会先通过poll方法，将任务队列的队头，也就是最旧的那个任务remove掉，然后将最新的task放进线程池

### CallerRunsPolicy
![image.png](http://upload-images.jianshu.io/upload_images/8923118-5623a7e77443ac0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看到，CallerRunsPolicy就是直接调用Runnable的实例方法run去执行该task，说白了就是该task直接由调用者线程来执行


### 后记

当然，以上四种拒绝策略只是jdk预定义的，我们也可以根据实际情况自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可


